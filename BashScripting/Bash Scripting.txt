BASIC LINUX COMMANDS

mkdir mynewdir:
    Function: Creates a new directory named "mynewdir."
    Example Output: No output is shown.
cd mynewdir/:
    Function: Changes the current working directory to "mynewdir."
    Example Output: No output is shown.
pwd:
    Function: Prints the current working directory.
    Example Output: /mynewdir$
cp ../spider.txt .:
    Function: Copies the file "spider.txt" from the parent directory to the current directory.
    Example Output: No output is shown.
touch myfile.txt:
    Function: Creates an empty file named "myfile.txt."
    Example Output: No output is shown.
ls -l:
    Function: Lists the contents of the current directory in long format.
    Example Output:
        -rw-rw-r-- 1 user user   0 Mai 22 14:22 emptyfile.txt
        -rw-rw-r-- 1 user user 192 Mai 22 14:18 spider.txt
        -rw-rw-r-- 1 user user 192 Mai 22 14:23 yetanotherfile.txt
ls -la:
    Function: Lists detailed information about all files and directories, including hidden ones.
    Example Output: Detailed directory listing.
mv myfile.txt emptyfile.txt:
    Function: Renames "myfile.txt" to "emptyfile.txt."
    Example Output: No output is shown.
cp spider.txt yetanotherfile.txt:
    Function: Copies "spider.txt" to create a new file named "yetanotherfile.txt."
    Example Output: No output is shown.
ls -l:
    Function: Lists the contents of the current directory in long format after the previous commands.
    Example Output: Total 8:
        -rw-rw-r-- 1 user user   0 Mai 22 14:22 emptyfile.txt
        -rw-rw-r-- 1 user user 192 Mai 22 14:18 spider.txt
        -rw-rw-r-- 1 user user 192 Mai 22 14:23 yetanotherfile.txt
rm *:
    Function: Removes all files in the current directory.
    Example Output: No output is shown.
ls -l:
    Function: Lists the contents of the current directory after removing files.
    Example Output: No files are listed; the total size is 0.
cd ..:
    Function: Changes the current working directory to the parent directory.
    Example Output: No output is shown.
rmdir mynewdir/:
    Function: Removes the directory "mynewdir."
    Example Output: No output is shown.
ls mynewdir:
    Function: Lists the contents of "mynewdir" (after it has been removed).
    Example Output: ls: cannot access 'mynewdir': No such file or directory

>>  A double greater than sign will append a command output to a file.

REDIRECTING STREAMS

cat stdout_example.py 
#!/usr/bin/env python3
print("Don't mind me, just a bit of text here...")
./stdout_example.py 
#Output: Don't mind me, just a bit of text here...
./stdout_example.py > new_file.txt
cat new_file.txt 
#Output: Don't mind me, just a bit of text here...
./stdout_example.py >> new_file.txt
cat new_file.txt 
#Output: Don't mind me, just a bit of text here...
 #Don't mind me, just a bit of text here...
cat streams_err.py 
#!/usr/bin/env python3

data = input("This will come from STDIN: ")
print("Now we write it to STDOUT: " + data)
raise ValueError("Now we generate an error to STDERR")
./streams_err.py < new_file.txt
#This will come from STDIN: Now we write it to STDOUT: Don't mind #me, just a bit of text here...
#Traceback (most recent call last):
  #File "./streams_err.py", line 5, in <module>
    #raise ValueError("Now we generate an error to STDERR")
#ValueError: Now we generate an error to STDERR
./streams_err.py < new_file.txt 2> error_file.txt
#This will come from STDIN: Now we write it to STDOUT: Don't mind #me, just a bit of text here...
cat error_file.txt 
#Traceback (most recent call last):
  #File "./streams_err.py", line 5, in <module>
    #raise ValueError("Now we generate an error to STDERR")
#ValueError: Now we generate an error to STDERR
echo "These are the contents of the file" > myamazingfile.txt
cat myamazingfile.txt 
#These are the contents of the file
______________________________

PIPES AND PIPELINES
Using pipes, you can connect multiple scripts, commands, or other programs 
together into a data processing pipeline.

Pipes connect the output of one program to the input of another. 
This means we can pass data between programs, taking the output of one and making 
it the input of the next. Pipes are represented by the pipe character.

It allows us to create new commands by combining the functionality of one command, 
    with the functionality of another without having to store the contents in an 
    intermediate file. So let's work on our plumbing, shall we? Here's an example. 
    Here, the output of the ls-l command is connected to the input of the less command, 
    which is a terminal paging program.

This example can be pretty useful when you want to look at the contents of a directory 
    containing lots of files. The list of files generated by ls is piped to less, 
    which displays them one page at a time. We can scroll up or down using the page up, 
    page down, or arrow keys. Once we're done looking at the files, we can quit with Q.

We're first using cat to get the contents of our spider.txt file. Those contents are 
    then sent to a command called tr, which gets its name from the word translate. 
    It takes the characters in the first parameter, in this case, it's a space and 
    then transform them into a character in the second parameter. In this case, it's a 
    newline character. So basically, what we're doing is putting each word in its own 
    separate line. Hurrah for organization. Next, we pass results to the sort command 
    through a pipe. This command sorts results alphabetically.

The sorted results are then passed to the unique command, which displays each match 
once, and by using a -c flag, it prefixes each unique line with a number of times it 
occurred. This output is passed via pipe to the sort command once more, this time, 
with the -nr flag, which sorts results numerically and in reverse order, from most to 
least hits. The output is finally passed to the head command, which prints the first 
10 lines to stdl. That's a lot of process, but when you break it down, it makes a lot 
of sense, right?

ls -l | less
#(... A list of files appears...)
cat spider.txt | tr ' ' '\n' | sort | uniq -c | sort -nr | head
     # 7 the
     # 3 up
     # 3 spider
     # 3 and
     # 2 rain
     # 2 itsy
     # 2 climbed
     # 2 came
     # 2 bitsy
     # 1 waterspout.
________

cat capitalize.py
#!/usr/bin/env python3

import sys

for line in sys.stdin:
    print(line.strip().capitalize())

    In this script, we're iterating over the contents of the sys.stdin file. 
    Remember, that when we iterate a file object, we go through it line by line.
    For each of the lines of a file, we first use the strip method to remove the 
    newline character at the end, then capitalize method to make the first character 
    of the line uppercase, and then we print it out to standard output
________

cat haiku.txt 
#advance your career,
#automating with Python,
#it's so fun to learn.
________

cat haiku.txt | ./capitalize.py 
#Advance your career,
#Automating with python,
#It's so fun to learn.

the cat command sends the contents of a Haiku.txt file to standard output, which we 
    redirect to our script using a pipe. Our capitalized script uses the sys stdin 
    file object to iterate through each line of standard input, printing the capitalized
    version to standard output. It's truly poetic, isn't it? We should also call out 
    that we don't need to use a pipe to get the contents of the Haiku.txt file into 
    standard input of our script. Instead, we use the redirection operator we saw in 
    the last video like this. As a rule, if you just need to get something from 
    standard input into your script, using a redirection is enough.
________


./capitalize.py < haiku.txt
#Advance your career,
#Automating with python,
#It's so fun to learn.
______________________________


SIGNALING PROCESSES

When dealing with the operating system, we usually have a bunch of different 
    processes that we use to accomplish what we want. And like any well oiled machine, 
    we generally need these processes to communicate with each other. For example, we 
    might have a program that starts a background process and wants it to terminate 
    after a timeout. One way of communicating this is through the pipelines we learned 
    about in the last video. Another way of communicating is through the use of signals. Signals are tokens delivered to running processes to indicate a desired action. Using signals, we can tell a program that we want it to pause or terminate. We can also cause it to reload its configuration, or to close all open files. Knowing how to send these signals lets us interact with processes and have more control over how they behave. There are a bunch of different ways that we can send these signals. For example, let's execute the ping command in our terminal.


ping www.example.com
#PING www.example.com(2606:2800:220:1:248:1893:25c8:1946 (2606:2800:220:1:248:1893:25c8:1946)) 56 data bytes

The ping command is now running, sending ICMP packets to the machine over the network 
    once per second. And it will keep running forever unless we interrupt it. 
    To do that, we can use the Ctrl-C combination.
________

 When we interrupt it, the program doesn't just end abruptly. First it prints a 
    summary of what it did and what the results were. It's very polite under these 
    circumstances.
Press Control C:

--- www.example.com ping statistics ---

9 packets transmitted, 9 received, 0% packet loss, time 8013ms

rtt min/avg/max/mdev = 93.587/93.668/93.719/0.149 ms
________

ping www.example.com
#PING www.example.com(2606:2800:220:1:248:1893:25c8:1946 (2606:2800:220:1:248:1893:25c8:1946)) 56 data bytes
________

 Press Control Z: the program stops. 

 The signal that we sent is called SIGSTOP. This signal causes the program to stop 
    running without actually terminating. But don't worry, we can make it run again 
    by executing fg. The fg command makes our program run once more and will keep going 
    until we interrupt it either with Ctrl-C, Ctrl-Z, or some other signal. 
________

fg
#ping www.example.com
#64 bytes from 2606:2800:220:1:248:1893:25c8:1946 (2606:2800:220:1:248:1893:25c8:1946): icmp_seq=5 ttl=51 time=93.6 ms
________

Press Control C:

--- www.example.com ping statistics ---

9 packets transmitted, 9 received, 0% packet loss, time 8013ms

rtt min/avg/max/mdev = 93.587/93.668/93.719/0.149 ms
________

Kill will send a signal called SIGTERM that tells the program to terminate. 
    Since Kill is a separate program, we need to run it on a separate terminal. 
    And we also need to know the process identifier or PID of the process that we
    want to send the signal to.
To find out the PID that we want to send the signal to, we'll use the ps command 
    which list the currently running processes. Depending on what options that we pass, 
    it'll show different subsets of processes with different amounts of detail.
For this example, we'll call ps ax, which lists all the running processes in the 
    current computer. And then we'll use the grep command to only keep lines that 
    contain the name of the process that we're looking for. Sound good? Okay, let's 
    try this out. We'll run ping on one terminal, and then find its PID and kill it 
    from a second terminal.
We won't get the nice summary at the end, the program will just finish.

______________________________

STUDY GUIDE
Study guide: Basic Linux commands
Basic Linux commands are beneficial to developers when interacting with a Linux operating system through the command line interface. They are used when working with files and directories. Typically, they are easy to learn and apply, and provide developers with additional commands for more advanced situations. If needed, these commands are also easy to look up on your preferred search engine.

In this reading, you will review basic Linux commands with examples provided along the way.

Managing files and directories
Many applications configure themselves by reading files. They are designed to read and write files in specific directories. Because of this, developers need to understand how to move and rename files, change their permissions, and do simple operations on their contents. Here are some common commands:

mv is used to move one or more files to a different directory, rename a file, or both at the same time.

Note: Linux is case-sensitive, so mv can also be used to change the case of a filename.

mv myfile.txt dir1/ This command moves a file to the directory.

mv file1.txt file2.txt file3.txt dir1/ This command moves multiple files.


cp is used to copy one or more files. Some examples include:

cp file1.txt file2.txt 

cp file1.txt file2.txt file3.txt dir1/


chmod/chown/chgrp is used to make a file readable to everyone on the system before moving it to a public directory. A common example is:

chmod +r file.html && mv file.html /var/www/html/index.html 

Operating with the content of files
Every programmer will use files for something. Whether it’s for configuration, data, or input and output, programmers work with files and need to know how to operate with their contents.

cut is a command that extracts fields from a data file. Two examples are:

cut -f1 -d”,” addressbook.csv This command extracts the first field from a .csv file.

cut -c1-3,5-7,9-12 phones.txt This command extracts only the digits from a list of phone numbers.


sort is a command that sorts the contents of a file. Some examples include:

sort names.txt This command sorts inputs alphabetically.

sort -r names.txt This command sorts inputs in reverse alphabetical order, starting with the letter z. 

sort -n numbers.txt This command treats the inputs as numbers and then sorts them numerically.


Some examples that include combining multiple commands are:

ls -l | cut -w -f5,9 | sort -rn | head -10 This command displays the 10 largest files in the current directory.


cut -f1-2 -d”,” addressbook.csv | sort This command extracts the first and last names from a .csv file and sorts them.

Additional commands
Additional commands that programmers commonly use are:

id  is a command that prints information about the current user. This command is useful if you are getting a permissions denied error and think you should be granted access to a file.

$ id

uid=3000(tradel) gid=3000(tradel) groups=3000(tradel),0(root),100(users),545(builtin_users),999(docker)


free is a command that prints information about memory on the current system.

free -h This command prints in human-readable units instead of bytes.

Key takeaways
Basic Linux commands assist developers in different types of tasks related to managing files and directories and working with the content of each file. These commands allow developers to work more efficiently and effectively.


______________________________

Redirections, Pipes, and Signals
Managing streams
These are the redirectors that we can use to take control of the streams of our programs

command > file: redirects standard output, overwrites file

command >> file: redirects standard output, appends to file

command < file: redirects standard input from file

command 2> file: redirects standard error to file

command1 | command2: connects the output of command1 to the input of command2

Operating with processes
These are some commands that are useful to know in Linux when interacting with processes. Not all of them are explained in videos, so feel free to investigate them on your own.

ps: lists the processes executing in the current terminal for the current user

ps ax: lists all processes currently executing for all users  

ps e: shows the environment for the processes listed  

kill PID: sends the SIGTERM signal to the process identified by PID

fg: causes a job that was stopped or in the background to return to the foreground

bg: causes a job that was stopped to go to the background

jobs: lists the jobs currently running or stopped

top: shows the processes currently using the most CPU time (press "q" to quit)  