UNIT test_dir_subprocess2

the Python code simulates a cake factory and performs different functions. 
These include choosing different sizes and flavors of a cake, including small, 
medium, and large, and chocolate or vanilla. In addition, the simple class allows 
developers to add sprinkles or cherries to the cake, return a list of ingredients, 
and return the price of the cake based on size and toppings.


from typing import List


class CakeFactory:
	def __init__(self, cake_type: str, size: str):
    	self.cake_type = cake_type
    	self.size = size
    	self.toppings = []
   	 
    	# Price based on cake type and size
    	self.price = 10 if self.cake_type == "chocolate" else 8
    	self.price += 2 if self.size == "medium" else 4 if self.size == "large" else 0


	def add_topping(self, topping: str):
    	self.toppings.append(topping)
    	# Adding 1 to the price for each topping
    	self.price += 1


	def check_ingredients(self) -> List[str]:
    	ingredients = ['flour', 'sugar', 'eggs']
    	ingredients.append('cocoa') if self.cake_type == "chocolate" else ingredients.append('vanilla extract')
    	ingredients += self.toppings
    	return ingredients


	def check_price(self) -> float:
    	return self.price


# Example of creating a cake and adding toppings
cake = CakeFactory("chocolate", "medium")
cake.add_topping("sprinkles")
cake.add_topping("cherries")
cake_ingredients = cake.check_ingredients()
cake_price = cake.check_price()


cake_ingredients, cake_price

OUTPUT:
(['flour', 'sugar', 'eggs', 'cocoa', 'sprinkles', 'cherries'], 14)


In the code above, the cake factor class and methods are defined. 
Now it’s time to define the unittest methods to test the different functions of the 
code. The test suite includes tests for the cake’s flavor, size, toppings, ingredients, 
and price. The first test case in the suite will intentionally provide the wrong 
value—and that’s what we want! Create specific statements to make sure the program is 
behaving as it should. That includes providing incorrect data to determine if the 
program will provide failed results. Because unittest is class-based,  encapsulate 
these statements into test methods.


import unittest


class TestCakeFactory(unittest.TestCase):
	def test_create_cake(self):
    	cake = CakeFactory("vanilla", "small")
    	self.assertEqual(cake.cake_type, "vanilla")
    	self.assertEqual(cake.size, "small")
    	self.assertEqual(cake.price, 8) # Vanilla cake, small size


	def test_add_topping(self):
    	cake = CakeFactory("chocolate", "large")
    	cake.add_topping("sprinkles")
    	self.assertIn("sprinkles", cake.toppings)


	def test_check_ingredients(self):
    	cake = CakeFactory("chocolate", "medium")
    	cake.add_topping("cherries")
    	ingredients = cake.check_ingredients()
    	self.assertIn("cocoa", ingredients)
    	self.assertIn("cherries", ingredients)
    	self.assertNotIn("vanilla extract", ingredients)


	def test_check_price(self):
    	cake = CakeFactory("vanilla", "large")
    	cake.add_topping("sprinkles")
    	cake.add_topping("cherries")
    	price = cake.check_price()
    	self.assertEqual(price, 13) # Vanilla cake, large size + 2 toppings


# Running the unittests
unittest.TextTestRunner().run(unittest.TestLoader().loadTestsFromTestCase(TestCakeFactory))


OUTPUT:


Ran 4 tests in 0.009s


FAILED (failures=1)


RESULT
<unittest.runner.TextTestResult run=4 errors=0 failures=1>


#The program calls the TextTestRunner() method, which returns a runner (TextTestResult). 
It says one failure occurred: the statement self.assertEqual(price, 13) was incorrect, 
as it should have been 14. How can we correct that part of the test? Update that part 
of the code to the following:


# Fixing the test_check_price method
class TestCakeFactory(unittest.TestCase):
	# ... Other tests remain the same


	def test_check_price(self):
    	cake = CakeFactory("vanilla", "large")
    	cake.add_topping("sprinkles")
    	cake.add_topping("cherries")
    	price = cake.check_price()
    	self.assertEqual(price, 14) # Vanilla cake, large size + 2 toppings


# Re-running the unittests
unittest.TextTestRunner().run(unittest.TestLoader().loadTestsFromTestCase(TestCakeFactory))

#And now the program works as expected, as the results provide no failures and are:

Ran 1 test in 0.004s

OK

RESULT

<unittest.runner.TextTestResult run=1 errors=0 failures=0>


-----------------------------------------------------------------------


#!/usr/bin/env python3
import re
def rearrange_name(name):
  result = re.search(r"^([\w .]*), ([\w .]*)$", name)
  return "{} {}".format(result[2], result[1])
from rearrange import rearrange_name


rearrange_name("Lovelace, Ada") 

______________

#!/usr/bin/env python3

import re

def rearrange_name(name):
  result = re.search(r"^([\w .]*), ([\w .]*)$", name)
  return "{} {}".format(result[2], result[1])


______________

#!/usr/bin/env python3

import unittest

from rearrange import rearrange_name

class TestRearrange(unittest.TestCase):
    
  def test_basic(self):
    testcase = "Lovelace, Ada"
    expected = "Ada Lovelace"
    self.assertEqual(rearrange_name(testcase), expected)

# Run the tests
unittest.main()

______________
EDGE CASES

def test_empty(self):
  testcase = ""
  expected = ""
  self.assertEqual(rearrange_name(testcase), expected)


./rearrange_test.py 

______________

#!/usr/bin/env python3

import re

def rearrange_name(name):
  result = re.search(r"^([\w .-]*), ([\w .-]*)$", name)
  if result is None:
    return ""
  return "{} {}".format(result[2], result[1])


./rearrange_test.py 

______________

TEST CASE AND EXPLANATION

from rearrange import rearrange_name
import unittest

class TestRearrange(unittest.TestCase):
  
  def test_basic(self):
    # Test case with a standard name format
    testcase = "Lovelace, Ada"
    expected = "Ada Lovelace"
    self.assertEqual(rearrange_name(testcase), expected)

  def test_empty(self):
    # Test case with an empty string
    testcase = ""
    expected = ""
    self.assertEqual(rearrange_name(testcase), expected)

  def test_double_name(self):
    # Test case with a name containing a middle initial
    testcase = "Hopper, Grace M."
    expected = "Grace M. Hopper"
    self.assertEqual(rearrange_name(testcase), expected)

  def test_one_name(self):
    # Test case with a single-name input
    testcase = "Voltaire"
    expected = "Voltaire"
    self.assertEqual(rearrange_name(testcase), expected)

# Run the tests
unittest.main()


from rearrange import rearrange_name

This line imports the rearrange_name function from the rearrange module. 
Presumably, this module contains the logic for rearranging names.
import unittest

This line imports the unittest module, which provides a testing framework.
class TestRearrange(unittest.TestCase):

This line defines a test class named TestRearrange that inherits from unittest.
TestCase. Test methods within this class should start with the word "test."
def test_basic(self):

This method defines a test case named test_basic.
It provides an input (testcase) in the format "Lovelace, Ada" and the expected 
output (expected) as "Ada Lovelace."
It uses self.assertEqual to check if the result of rearrange_name(testcase) matches 
the expected output.
def test_empty(self):

Similar to the previous method, this test case handles an empty string input.
def test_double_name(self):

This test case deals with a name containing a middle initial, like "Hopper, Grace M."
def test_one_name(self):

This test case handles a single-name input, like "Voltaire."
unittest.main()

This line runs the tests when the script is executed. It triggers the test discovery
 and execution within the unittest framework.
When you run this script, the unittest framework will execute each test case method 
and report whether the actual results match the expected results. If everything is 
correct, there should be no output. If a test fails, the framework will provide 
information about the failure.

______________

import re

def rearrange_name(name):
  result = re.search(r"^([\w .]*), ([\w .]*)$", name)
  if result is None:
    return name
  return "{} {}".format(result[2], result[1])

./rearrange_test.py 
